# core/downloader.py - CÓDIGO COMPARTIDO ACTUALIZADO Ver 1.2
from pytubefix import YouTube
from mutagen.mp3 import MP3
from mutagen.id3 import ID3, APIC, TIT2, TPE1, TALB, TYER, TRCK, TCON, TPE2, COMM
import requests
import subprocess
import uuid
import os
import shutil
import re
from pathlib import Path
from dataclasses import dataclass
from typing import Optional, Tuple, Dict, List
import time
from datetime import datetime


@dataclass
class VideoInfo:
    """Información del video"""
    title: str
    author: str
    video_id: str
    duration: int
    views: int
    thumbnail_url: str
    length_formatted: str
    is_auto_generated: bool
    extracted_metadata: Optional[Dict] = None


@dataclass
class MusicMetadata:
    """Metadatos extraídos de videos auto-generated"""
    song_title: str
    artists: List[str]
    album: str
    release_date: Optional[str]
    year: Optional[str]
    label: Optional[str]
    composers: List[str]
    is_official: bool


class YouTubeDownloaderCore:
    """Clase base con toda la lógica de descarga - Actualizada para Auto-generated"""
    
    def __init__(self, temp_dir: str = "temp"):
        self.temp_dir = Path(temp_dir)
        self.temp_dir.mkdir(exist_ok=True)
    
    def get_video_info(self, url: str) -> Optional[VideoInfo]:
        """Obtiene información del video y detecta si es auto-generated"""
        try:
            yt = YouTube(url)
            
            # Verificar si es auto-generated
            is_auto_generated = self._is_auto_generated(yt)
            
            # Extraer metadatos si es auto-generated
            extracted_metadata = None
            if is_auto_generated:
                extracted_metadata = self._extract_auto_generated_metadata(yt)
            
            # Obtener mejor thumbnail
            thumbnail_candidates = [
                f"https://i.ytimg.com/vi/{yt.video_id}/maxresdefault.jpg",
                f"https://i.ytimg.com/vi/{yt.video_id}/sddefault.jpg",
                f"https://i.ytimg.com/vi/{yt.video_id}/hqdefault.jpg",
            ]
            
            thumbnail_url = yt.thumbnail_url
            for thumb_url in thumbnail_candidates:
                try:
                    response = requests.get(thumb_url, timeout=3)
                    if response.status_code == 200:
                        thumbnail_url = thumb_url
                        break
                except:
                    continue
            
            # Formatear duración
            duration = yt.length
            if duration < 3600:
                length_formatted = f"{duration//60}:{duration%60:02d}"
            else:
                length_formatted = f"{duration//3600}:{(duration%3600)//60:02d}:{duration%60:02d}"
            
            return VideoInfo(
                title=yt.title,
                author=yt.author,
                video_id=yt.video_id,
                duration=duration,
                views=yt.views,
                thumbnail_url=thumbnail_url,
                length_formatted=length_formatted,
                is_auto_generated=is_auto_generated,
                extracted_metadata=extracted_metadata
            )
            
        except Exception as e:
            raise Exception(f"Error obteniendo info: {str(e)}")
    
    def _is_auto_generated(self, yt: YouTube) -> bool:
        """Detecta si el video es 'Auto-generated by YouTube'"""
        # Patrones para detectar videos auto-generated
        description = yt.description.lower()
        title = yt.title.lower()
        author = yt.author.lower()
        
        # Indicadores clave
        indicators = [
            'provided to youtube by' in description,
            'auto-generated by youtube' in description,
            '- topic' in author,
            'topic' in author and len(author) > 10,
            'released on:' in description,
            any(x in description for x in ['·', '•', '♪']),  # Caracteres especiales comunes
            'full album' in title or 'complete album' in title,
        ]
        
        # Si tiene al menos 2 indicadores, probablemente sea auto-generated
        return sum(indicators) >= 2
    
    def _extract_auto_generated_metadata(self, yt: YouTube) -> Optional[MusicMetadata]:
        """Extrae metadatos de videos auto-generated como el ejemplo dado"""
        
        try:
            desc = yt.description
            
            # Ejemplo del formato:
            # Provided to YouTube by NexTone Inc.
            #
            # Full Moon Full Life · Azumi Takahashi · Lotus Juice · ATLUS Sound Team · ATLUS GAME MUSIC · Lotus Juice · ATLUS Sound Team · ATLUS Sound Team
            #
            # Persona 3 Reload Original Soundtrack
            #
            # Released on: 2024-04-24
            #
            # Auto-generated by YouTube.
            
            lines = [line.strip() for line in desc.split('\n') if line.strip()]
            
            if len(lines) < 3:
                return None
            
            metadata = {
                'song_title': '',
                'artists': [],
                'album': '',
                'release_date': None,
                'year': None,
                'label': None,
                'composers': [],
                'is_official': True
            }
            
            # Buscar etiqueta 'Provided to YouTube by' (sello discográfico)
            for i, line in enumerate(lines):
                if 'provided to youtube by' in line.lower():
                    label_match = re.search(r'Provided to YouTube by\s*(.+)', line, re.IGNORECASE)
                    if label_match:
                        metadata['label'] = label_match.group(1).strip()
                        break
            
            # Buscar línea con el título y artistas (usualmente línea 1 o 2 después del label)
            # Formato: "Título · Artista1 · Artista2 · ..."
            for i, line in enumerate(lines):
                if '·' in line and len(line) > 10:
                    parts = [p.strip() for p in line.split('·')]
                    
                    if parts:
                        # El primer elemento es el título de la canción
                        metadata['song_title'] = parts[0]
                        
                        # Los siguientes son artistas/compositores
                        if len(parts) > 1:
                            # Eliminar duplicados manteniendo orden
                            unique_artists = []
                            for artist in parts[1:]:
                                if artist and artist not in unique_artists:
                                    unique_artists.append(artist)
                            metadata['artists'] = unique_artists
                        
                        # También podrían ser compositores
                        metadata['composers'] = metadata['artists'].copy()
                        break
            
            # Buscar álbum (usualmente después de la línea de artistas)
            for i, line in enumerate(lines):
                if line and len(line) > 5 and '·' not in line:
                    # Si no es el label, no es la fecha, y no tiene caracteres especiales
                    if ('provided' not in line.lower() and 
                        'released' not in line.lower() and 
                        'auto-generated' not in line.lower()):
                        # Verificar que no sea el título (ya lo tenemos)
                        if line != metadata['song_title'] and line not in metadata['artists']:
                            metadata['album'] = line
                            break
            
            # Buscar fecha de lanzamiento
            for line in lines:
                if 'released on:' in line.lower():
                    date_match = re.search(r'Released on:\s*(.+)', line, re.IGNORECASE)
                    if date_match:
                        date_str = date_match.group(1).strip()
                        metadata['release_date'] = date_str
                        
                        # Extraer año
                        year_match = re.search(r'(\d{4})', date_str)
                        if year_match:
                            metadata['year'] = year_match.group(1)
                        break
            
            # Si no encontramos título en descripción, usar título del video
            if not metadata['song_title']:
                # Intentar extraer del título del video
                title_parts = yt.title.split(' - ')
                if len(title_parts) >= 2:
                    metadata['song_title'] = title_parts[1].split('(')[0].strip()
                else:
                    metadata['song_title'] = yt.title
            
            # Limpiar datos
            if metadata['song_title']:
                metadata['song_title'] = self._clean_text(metadata['song_title'])
            
            if metadata['album']:
                metadata['album'] = self._clean_text(metadata['album'])
            
            return MusicMetadata(**metadata)
            
        except Exception as e:
            print(f"Advertencia extrayendo metadatos: {e}")
            return None
    
    def _clean_text(self, text: str) -> str:
        """Limpia texto de caracteres extraños"""
        # Remover caracteres de control y espacios extras
        text = re.sub(r'\s+', ' ', text)
        text = text.strip()
        
        # Remover texto entre paréntesis/brackets si son comunes
        text = re.sub(r'\([^)]*\)', '', text)  # (Official Video)
        text = re.sub(r'\[[^\]]*\]', '', text)  # [4K]
        text = re.sub(r'【[^】]*】', '', text)  # 【Full HD】
        
        return text.strip()
    
    def _get_best_audio_stream(self, yt: YouTube, is_auto_generated: bool = False):
        """Selecciona el mejor stream de audio según el tipo de video"""
        
        audio_streams = yt.streams.filter(only_audio=True)
        
        if not audio_streams:
            raise Exception("No se encontraron streams de audio")
        
        # Prioridad de itags según tipo de video
        if is_auto_generated:
            # Para música auto-generated, priorizar calidad
            priority_itags = [
                '251',  # webm/opus 160k (óptimo para música)
                '250',  # webm/opus 70k
                '140',  # m4a/aac 128k (compatible)
                '139',  # m4a/aac 48k
            ]
        else:
            # Para videos normales
            priority_itags = [
                '140',  # m4a/aac 128k (balance)
                '251',  # webm/opus 160k
                '139',  # m4a/aac 48k
            ]
        
        # Buscar por orden de prioridad
        for itag in priority_itags:
            stream = audio_streams.get_by_itag(itag)
            if stream:
                return stream
        
        # Si no encuentra, devolver el de mayor bitrate
        return audio_streams.order_by('abr').last()
    
    def download_mp3(self, url: str, output_path: Optional[Path] = None, 
                     preserve_metadata: bool = True) -> Path:
        """Descarga y convierte a MP3 con metadatos optimizados"""
        try:
            # Obtener información del video
            video_info = self.get_video_info(url)
            yt = YouTube(url)
            
            # Descargar thumbnail
            thumbnail_data = None
            try:
                response = requests.get(video_info.thumbnail_url, timeout=5)
                if response.status_code == 200:
                    thumbnail_data = response.content
            except:
                pass
            
            # Obtener mejor stream de audio según tipo
            audio_stream = self._get_best_audio_stream(yt, video_info.is_auto_generated)
            
            # Archivos temporales
            temp_audio = self.temp_dir / f"{uuid.uuid4()}.{self._get_audio_extension(audio_stream)}"
            temp_mp3 = self.temp_dir / f"{uuid.uuid4()}.mp3"
            
            # Descargar audio
            print(f"Descargando audio: {audio_stream.abr} ({audio_stream.mime_type})")
            audio_stream.download(output_path=str(self.temp_dir), filename=temp_audio.name)
            
            # Convertir a MP3 con FFmpeg
            ffmpeg_cmd = [
                "ffmpeg", "-y", "-i", str(temp_audio),
                "-codec:a", "libmp3lame",
                "-q:a", "2",  # Calidad 2 (VBR ~190-250kbps)
                "-vn", str(temp_mp3)
            ]
            
            subprocess.run(ffmpeg_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            
            # Añadir metadatos ID3
            if preserve_metadata and video_info.extracted_metadata:
                self._add_complete_id3_tags(
                    temp_mp3, 
                    video_info,
                    thumbnail_data
                )
            elif preserve_metadata:
                self._add_basic_id3_tags(
                    temp_mp3,
                    video_info.title,
                    video_info.author,
                    "YouTube",
                    thumbnail_data
                )
            
            # Definir nombre de archivo final
            if output_path is None:
                if video_info.extracted_metadata and video_info.extracted_metadata.song_title:
                    base_name = f"{video_info.extracted_metadata.song_title}"
                    if video_info.extracted_metadata.artists:
                        base_name = f"{video_info.extracted_metadata.artists[0]} - {base_name}"
                else:
                    base_name = video_info.title
                
                safe_name = self.sanitize_filename(base_name)
                output_path = Path.cwd() / f"{safe_name}.mp3"
            
            # Mover archivo final
            shutil.move(str(temp_mp3), str(output_path))
            
            # Limpiar temporal
            temp_audio.unlink(missing_ok=True)
            
            return output_path
            
        except Exception as e:
            raise Exception(f"Error descargando MP3: {str(e)}")
    
    def _add_complete_id3_tags(self, mp3_path: Path, video_info: VideoInfo, 
                               thumbnail_data: Optional[bytes] = None):
        """Añade metadatos ID3 completos para videos auto-generated"""
        try:
            audio = MP3(str(mp3_path), ID3=ID3)
            if audio.tags is None:
                audio.add_tags()
            
            metadata = video_info.extracted_metadata
            
            # Título de la canción
            if metadata.song_title:
                audio.tags.add(TIT2(encoding=3, text=metadata.song_title))
            else:
                audio.tags.add(TIT2(encoding=3, text=video_info.title))
            
            # Artista principal (primer artista)
            if metadata.artists:
                audio.tags.add(TPE1(encoding=3, text=metadata.artists[0]))
                # Album artist (puede ser diferente)
                audio.tags.add(TPE2(encoding=3, text=metadata.artists[0]))
            else:
                audio.tags.add(TPE1(encoding=3, text=video_info.author))
            
            # Álbum
            if metadata.album:
                audio.tags.add(TALB(encoding=3, text=metadata.album))
            else:
                audio.tags.add(TALB(encoding=3, text="YouTube"))
            
            # Año
            if metadata.year:
                audio.tags.add(TYER(encoding=3, text=metadata.year))
            elif video_info.publish_date:
                audio.tags.add(TYER(encoding=3, text=str(video_info.publish_date.year)))
            
            # Género (podemos inferir o dejar vacío)
            audio.tags.add(TCON(encoding=3, text="Soundtrack" if "soundtrack" in metadata.album.lower() else "Music"))
            
            # Comentario con información adicional
            comment_text = f"Source: YouTube | Channel: {video_info.author}"
            if metadata.label:
                comment_text += f" | Label: {metadata.label}"
            audio.tags.add(COMM(encoding=3, lang='eng', desc='', text=comment_text))
            
            # Número de pista (podríamos intentar inferir si es un tracklist)
            # Por ahora dejamos vacío
            
            # Thumbnail
            if thumbnail_data:
                audio.tags.add(APIC(
                    encoding=3,
                    mime='image/jpeg',
                    type=3,
                    desc='Cover',
                    data=thumbnail_data
                ))
            
            audio.save(v2_version=3)
            
        except Exception as e:
            print(f"Advertencia al añadir metadatos completos: {e}")
            # Intentar metadatos básicos
            self._add_basic_id3_tags(
                mp3_path,
                video_info.title,
                video_info.author,
                metadata.album if metadata else "YouTube",
                thumbnail_data
            )
    
    def _add_basic_id3_tags(self, mp3_path: Path, title: str, artist: str, 
                            album: str, thumbnail_data: Optional[bytes] = None):
        """Añade metadatos ID3 básicos"""
        try:
            audio = MP3(str(mp3_path), ID3=ID3)
            if audio.tags is None:
                audio.add_tags()
            
            audio.tags.add(TIT2(encoding=3, text=title[:100]))
            audio.tags.add(TPE1(encoding=3, text=artist[:100]))
            audio.tags.add(TALB(encoding=3, text=album[:100]))
            
            if thumbnail_data:
                audio.tags.add(APIC(
                    encoding=3,
                    mime='image/jpeg',
                    type=3,
                    desc='Cover',
                    data=thumbnail_data
                ))
            
            audio.save(v2_version=3)
            
        except Exception as e:
            print(f"Advertencia al añadir metadatos básicos: {e}")
    
    def _get_audio_extension(self, stream) -> str:
        """Obtiene extensión apropiada para el stream de audio"""
        mime_type = stream.mime_type.lower()
        
        if 'webm' in mime_type:
            return 'webm'
        elif 'mp4' in mime_type or 'm4a' in mime_type:
            return 'm4a'
        else:
            return 'mp3'
        
        
    def download_mp4(self, url: str, quality: int = 5, output_path: Optional[Path] = None) -> Path:
        """Descarga y convierte a MP4 con soporte para 240p y 480p"""
        try:
            video_info = self.get_video_info(url)
            yt = YouTube(url)
            
            # Mapear calidad - CON 240p Y 480p ✅
            quality_map = {
                1: "144p",
                2: "240p",      # ✅ NUEVO
                3: "360p",      # ✅ Movido
                4: "480p",      # ✅ NUEVO
                5: "720p",      # ✅ Movido
                6: "1080p",     # ✅ Movido
                7: "max"        # ✅ Movido
            }
            
            # Validar calidad
            if quality not in quality_map:
                quality = 5  # Por defecto 720p (ahora posición 5)
            
            resolution = quality_map.get(quality, "720p")
            
            # Descargar audio
            audio_stream = self._get_best_audio_stream(yt, video_info.is_auto_generated)
            temp_audio = self.temp_dir / f"audio_{uuid.uuid4()}.{self._get_audio_extension(audio_stream)}"
            audio_stream.download(output_path=str(self.temp_dir), filename=temp_audio.name)
            
            # Descargar video
            if quality == 7:  # ✅ max calidad
                video_stream = yt.streams.filter(
                    mime_type="video/mp4",
                    progressive=False
                ).order_by("resolution").desc().first()
            else:
                # Primero buscar exacto
                video_stream = yt.streams.filter(
                    mime_type="video/mp4",
                    res=f"{resolution}",
                    progressive=False
                ).first()
                
                # Si no encuentra, buscar progresivo (audio+video juntos)
                if not video_stream:
                    video_stream = yt.streams.filter(
                        mime_type="video/mp4",
                        res=f"{resolution}",
                        progressive=True
                    ).first()
                
                # Si aún no encuentra, buscar la mejor disponible
                if not video_stream:
                    self._find_best_available_stream(yt, resolution)
            
            if not video_stream:
                raise Exception(f"No se encontró video en {resolution}")
            
            temp_video = self.temp_dir / f"video_{uuid.uuid4()}.mp4"
            video_stream.download(output_path=str(self.temp_dir), filename=temp_video.name)
            
            # Si el stream es progresivo (ya tiene audio), no necesitamos combinar
            if video_stream.is_progressive:
                # Solo renombrar
                if output_path is None:
                    if video_info.extracted_metadata and video_info.extracted_metadata.song_title:
                        base_name = f"{video_info.extracted_metadata.song_title}"
                    else:
                        base_name = video_info.title
                    
                    safe_name = self.sanitize_filename(base_name)
                    output_path = Path.cwd() / f"{safe_name}_{resolution}.mp4"
                
                shutil.move(str(temp_video), str(output_path))
                temp_audio.unlink(missing_ok=True)  # No necesitamos audio separado
                
            else:
                # Combinar audio y video
                temp_combined = self.temp_dir / f"combined_{uuid.uuid4()}.mp4"
                
                ffmpeg_cmd = [
                    "ffmpeg", "-y",
                    "-i", str(temp_video),
                    "-i", str(temp_audio),
                    "-c:v", "copy",
                    "-c:a", "aac",
                    "-b:a", "192k",
                    "-shortest",
                    str(temp_combined)
                ]
                
                subprocess.run(ffmpeg_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                
                # Definir nombre de salida
                if output_path is None:
                    if video_info.extracted_metadata and video_info.extracted_metadata.song_title:
                        base_name = f"{video_info.extracted_metadata.song_title}"
                    else:
                        base_name = video_info.title
                    
                    safe_name = self.sanitize_filename(base_name)
                    output_path = Path.cwd() / f"{safe_name}_{resolution}.mp4"
                
                # Mover archivo
                shutil.move(str(temp_combined), str(output_path))
                
                # Limpiar
                temp_audio.unlink(missing_ok=True)
                temp_video.unlink(missing_ok=True)
            
            return output_path
            
        except Exception as e:
            raise Exception(f"Error descargando MP4: {str(e)}")

    def get_available_streams(self, url: str) -> list:
        """Obtiene lista de streams disponibles"""
        try:
            yt = YouTube(url)
            streams = []
            
            for stream in yt.streams:
                stream_info = {
                    'itag': stream.itag,
                    'mime_type': stream.mime_type,
                    'resolution': stream.resolution,
                    'abr': stream.abr,
                    'fps': stream.fps,
                    'filesize': stream.filesize_mb if hasattr(stream, 'filesize_mb') else None,
                    'has_audio': stream.includes_audio_track,
                    'is_progressive': stream.is_progressive,
                    'codecs': stream.codecs if hasattr(stream, 'codecs') else None
                }
                
                # Para audio, mostrar bitrate claro
                if stream.only_audio:
                    stream_info['type'] = 'audio'
                    if stream.abr:
                        stream_info['quality'] = f"Audio {stream.abr}"
                else:
                    stream_info['type'] = 'video'
                    if stream.resolution:
                        stream_info['quality'] = f"Video {stream.resolution}"
                
                streams.append(stream_info)
            
            return sorted(streams, key=lambda x: (
                0 if x['type'] == 'video' else 1,
                self._parse_resolution(x.get('resolution', '0p')),
                self._parse_bitrate(x.get('abr', '0kbps'))
            ))
            
        except Exception as e:
            raise Exception(f"Error obteniendo streams: {str(e)}")
    
    def _parse_resolution(self, res: str) -> int:
        """Convierte resolución a número para ordenar"""
        if not res or 'p' not in res:
            return 0
        
        try:
            return int(res.replace('p', ''))
        except:
            return 0
    
    def _parse_bitrate(self, abr: str) -> int:
        """Convierte bitrate a número para ordenar"""
        if not abr or 'kbps' not in abr:
            return 0
        
        try:
            return int(abr.replace('kbps', ''))
        except:
            return 0
    
    def get_detailed_info(self, url: str) -> Dict:
        """Obtiene información detallada del video"""
        try:
            video_info = self.get_video_info(url)
            yt = YouTube(url)
            
            info = {
                'basic': {
                    'title': video_info.title,
                    'channel': video_info.author,
                    'duration': video_info.duration,
                    'duration_formatted': video_info.length_formatted,
                    'views': video_info.views,
                    'publish_date': str(yt.publish_date) if hasattr(yt, 'publish_date') else None,
                    'video_id': video_info.video_id,
                    'is_auto_generated': video_info.is_auto_generated,
                },
                'thumbnail': video_info.thumbnail_url,
                'available_streams': len(yt.streams),
                'description_preview': yt.description[:200] + '...' if len(yt.description) > 200 else yt.description,
            }
            
            # Añadir metadatos extraídos si existen
            if video_info.extracted_metadata:
                info['music_metadata'] = {
                    'song_title': video_info.extracted_metadata.song_title,
                    'artists': video_info.extracted_metadata.artists,
                    'album': video_info.extracted_metadata.album,
                    'release_date': video_info.extracted_metadata.release_date,
                    'year': video_info.extracted_metadata.year,
                    'label': video_info.extracted_metadata.label,
                    'composers': video_info.extracted_metadata.composers,
                    'is_official': video_info.extracted_metadata.is_official,
                }
            
            return info
            
        except Exception as e:
            raise Exception(f"Error obteniendo info detallada: {str(e)}")
    
    def sanitize_filename(self, filename: str) -> str:
        """Limpia el nombre de archivo"""
        # Caracteres inválidos en Windows/Linux/Mac
        invalid_chars = '<>:"/\\|?*\''
        for char in invalid_chars:
            filename = filename.replace(char, '')
        
        # Limitar longitud y remover espacios extra
        filename = re.sub(r'\s+', ' ', filename).strip()
        
        return filename[:150]  # Limitar a 150 caracteres
    
    def cleanup(self):
        """Limpia archivos temporales"""
        if self.temp_dir.exists():
            try:
                shutil.rmtree(self.temp_dir)
                self.temp_dir.mkdir(exist_ok=True)
            except:
                pass