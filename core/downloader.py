# core/downloader.py - CÃ“DIGO COMPARTIDO ACTUALIZADO Ver 1.3
from pytubefix import YouTube
from mutagen.mp3 import MP3
from mutagen.id3 import ID3, APIC, TIT2, TPE1, TALB, TYER, TRCK, TCON, TPE2, COMM
import requests
import subprocess
import uuid
import os
import shutil
import re
from pathlib import Path
from dataclasses import dataclass
from typing import Optional, Tuple, Dict, List
import time
from datetime import datetime


# Dataclase general de la disposicion de informacion de video
@dataclass
class VideoInfo:
    """InformaciÃ³n del video"""
    title: str
    author: str
    video_id: str
    duration: int
    views: int
    thumbnail_url: str
    length_formatted: str
    is_auto_generated: bool
    extracted_metadata: Optional[Dict] = None

# Dataclase general de la disposicion de metadata de video
@dataclass
class MusicMetadata:
    """Metadatos extraÃ­dos de videos auto-generated"""
    song_title: str
    artists: List[str]
    album: str
    release_date: Optional[str]
    year: Optional[str]
    label: Optional[str]
    composers: List[str]
    is_official: bool


# Clase encargada del proceso logico de descarga (Actualizado para videos Auto-Generated)
class YouTubeDownloaderCore:
    """Clase base con toda la lÃ³gica de descarga - Actualizada para Auto-generated"""
    
    def __init__(self, temp_dir: str = "temp"):
        self.temp_dir = Path(temp_dir)
        self.temp_dir.mkdir(exist_ok=True)
        
        # AGRGADO
        # Verificar FFmpeg al inicio
        self.ffmpeg_available = self._check_ffmpeg()
        
        # AGREGADO
        if not self.ffmpeg_available:
            self._display_ffmpeg_warning()
    
    # Metodo encargado de conseguir la infromacion de video
    def get_video_info(self, url: str) -> Optional[VideoInfo]:
        """Obtiene informaciÃ³n del video y detecta si es auto-generated"""
        try:
            yt = YouTube(url)
            
            # Verificar si es auto-generated
            is_auto_generated = self._is_auto_generated(yt)
            
            # Extraer metadatos si es auto-generated
            extracted_metadata = None
            if is_auto_generated:
                extracted_metadata = self._extract_auto_generated_metadata(yt)
            
            # Obtener mejor thumbnail
            thumbnail_candidates = [
                f"https://i.ytimg.com/vi/{yt.video_id}/maxresdefault.jpg",
                f"https://i.ytimg.com/vi/{yt.video_id}/sddefault.jpg",
                f"https://i.ytimg.com/vi/{yt.video_id}/hqdefault.jpg",
            ]
            
            thumbnail_url = yt.thumbnail_url
            for thumb_url in thumbnail_candidates:
                try:
                    response = requests.get(thumb_url, timeout=3)
                    if response.status_code == 200:
                        thumbnail_url = thumb_url
                        break
                except:
                    continue
            
            # Formatear duraciÃ³n
            duration = yt.length
            if duration < 3600:
                length_formatted = f"{duration//60}:{duration%60:02d}"
            else:
                length_formatted = f"{duration//3600}:{(duration%3600)//60:02d}:{duration%60:02d}"
            
            return VideoInfo(
                title=yt.title,
                author=yt.author,
                video_id=yt.video_id,
                duration=duration,
                views=yt.views,
                thumbnail_url=thumbnail_url,
                length_formatted=length_formatted,
                is_auto_generated=is_auto_generated,
                extracted_metadata=extracted_metadata
            )
            
        except Exception as e:
            raise Exception(f"Error obteniendo info: {str(e)}")
    
    # Metodo que detecta si es un video Auto Generated 
    def _is_auto_generated(self, yt: YouTube) -> bool:
        """Detecta si el video es 'Auto-generated by YouTube'"""
        # Patrones para detectar videos auto-generated
        description = yt.description.lower()
        title = yt.title.lower()
        author = yt.author.lower()
        
        # Indicadores clave
        indicators = [
            'provided to youtube by' in description,
            'auto-generated by youtube' in description,
            '- topic' in author,
            'topic' in author and len(author) > 10,
            'released on:' in description,
            any(x in description for x in ['Â·', 'â€¢', 'â™ª']),  # Caracteres especiales comunes
            'full album' in title or 'complete album' in title,
        ]
        
        # Si tiene al menos 2 indicadores, probablemente sea auto-generated
        return sum(indicators) >= 2
    
    # Metodo dpara extraer los metadatos para videos Auto Generated
    def _extract_auto_generated_metadata(self, yt: YouTube) -> Optional[MusicMetadata]:
        """Extrae metadatos de videos auto-generated como el ejemplo dado"""
        
        try:
            desc = yt.description
            
            # Ejemplo del formato:
            # Provided to YouTube by NexTone Inc.
            #
            # Full Moon Full Life Â· Azumi Takahashi Â· Lotus Juice Â· ATLUS Sound Team Â· ATLUS GAME MUSIC Â· Lotus Juice Â· ATLUS Sound Team Â· ATLUS Sound Team
            #
            # Persona 3 Reload Original Soundtrack
            #
            # Released on: 2024-04-24
            #
            # Auto-generated by YouTube.
            
            lines = [line.strip() for line in desc.split('\n') if line.strip()]
            
            if len(lines) < 3:
                return None
            
            metadata = {
                'song_title': '',
                'artists': [],
                'album': '',
                'release_date': None,
                'year': None,
                'label': None,
                'composers': [],
                'is_official': True
            }
            
            # Buscar etiqueta 'Provided to YouTube by' (sello discogrÃ¡fico)
            for i, line in enumerate(lines):
                if 'provided to youtube by' in line.lower():
                    label_match = re.search(r'Provided to YouTube by\s*(.+)', line, re.IGNORECASE)
                    if label_match:
                        metadata['label'] = label_match.group(1).strip()
                        break
            
            # Buscar lÃ­nea con el tÃ­tulo y artistas (usualmente lÃ­nea 1 o 2 despuÃ©s del label)
            # Formato: "TÃ­tulo Â· Artista1 Â· Artista2 Â· ..."
            for i, line in enumerate(lines):
                if 'Â·' in line and len(line) > 10:
                    parts = [p.strip() for p in line.split('Â·')]
                    
                    if parts:
                        # El primer elemento es el tÃ­tulo de la canciÃ³n
                        metadata['song_title'] = parts[0]
                        
                        # Los siguientes son artistas/compositores
                        if len(parts) > 1:
                            # Eliminar duplicados manteniendo orden
                            unique_artists = []
                            for artist in parts[1:]:
                                if artist and artist not in unique_artists:
                                    unique_artists.append(artist)
                            metadata['artists'] = unique_artists
                        
                        # TambiÃ©n podrÃ­an ser compositores
                        metadata['composers'] = metadata['artists'].copy()
                        break
            
            # Buscar Ã¡lbum (usualmente despuÃ©s de la lÃ­nea de artistas)
            for i, line in enumerate(lines):
                if line and len(line) > 5 and 'Â·' not in line:
                    # Si no es el label, no es la fecha, y no tiene caracteres especiales
                    if ('provided' not in line.lower() and 
                        'released' not in line.lower() and 
                        'auto-generated' not in line.lower()):
                        # Verificar que no sea el tÃ­tulo (ya lo tenemos)
                        if line != metadata['song_title'] and line not in metadata['artists']:
                            metadata['album'] = line
                            break
            
            # Buscar fecha de lanzamiento
            for line in lines:
                if 'released on:' in line.lower():
                    date_match = re.search(r'Released on:\s*(.+)', line, re.IGNORECASE)
                    if date_match:
                        date_str = date_match.group(1).strip()
                        metadata['release_date'] = date_str
                        
                        # Extraer aÃ±o
                        year_match = re.search(r'(\d{4})', date_str)
                        if year_match:
                            metadata['year'] = year_match.group(1)
                        break
            
            # Si no encontramos tÃ­tulo en descripciÃ³n, usar tÃ­tulo del video
            if not metadata['song_title']:
                # Intentar extraer del tÃ­tulo del video
                title_parts = yt.title.split(' - ')
                if len(title_parts) >= 2:
                    metadata['song_title'] = title_parts[1].split('(')[0].strip()
                else:
                    metadata['song_title'] = yt.title
            
            # Limpiar datos
            if metadata['song_title']:
                metadata['song_title'] = self._clean_text(metadata['song_title'])
            
            if metadata['album']:
                metadata['album'] = self._clean_text(metadata['album'])
            
            return MusicMetadata(**metadata)
            
        except Exception as e:
            print(f"Advertencia extrayendo metadatos: {e}")
            return None
    
    # Metodo que limpia correctamente texto
    def _clean_text(self, text: str) -> str:
        """Limpia texto de caracteres extraÃ±os"""
        # Remover caracteres de control y espacios extras
        text = re.sub(r'\s+', ' ', text)
        text = text.strip()
        
        # Remover texto entre parÃ©ntesis/brackets si son comunes
        text = re.sub(r'\([^)]*\)', '', text)  # (Official Video)
        text = re.sub(r'\[[^\]]*\]', '', text)  # [4K]
        text = re.sub(r'ã€[^ã€‘]*ã€‘', '', text)  # ã€Full HDã€‘
        
        return text.strip()
    
    # Metodo que obtiene la mejor calidad de audio 
    def _get_best_audio_stream(self, yt: YouTube, is_auto_generated: bool = False):
        """Selecciona el mejor stream de audio segÃºn el tipo de video"""
        
        audio_streams = yt.streams.filter(only_audio=True)
        
        if not audio_streams:
            raise Exception("No se encontraron streams de audio")
        
        # Prioridad de itags segÃºn tipo de video
        if is_auto_generated:
            # Para mÃºsica auto-generated, priorizar calidad
            priority_itags = [
                '251',  # webm/opus 160k (Ã³ptimo para mÃºsica)
                '250',  # webm/opus 70k
                '140',  # m4a/aac 128k (compatible)
                '139',  # m4a/aac 48k
            ]
        else:
            # Para videos normales
            priority_itags = [
                '140',  # m4a/aac 128k (balance)
                '251',  # webm/opus 160k
                '139',  # m4a/aac 48k
            ]
        
        # Buscar por orden de prioridad
        for itag in priority_itags:
            stream = audio_streams.get_by_itag(itag)
            if stream:
                return stream
        
        # Si no encuentra, devolver el de mayor bitrate
        return audio_streams.order_by('abr').last()
    
    # Metodo especial que descarga y convierte a MP3
    def download_mp3(self, url: str, output_path: Optional[Path] = None, 
                     preserve_metadata: bool = True) -> Path:
        """Descarga y convierte a MP3 con metadatos optimizados"""
        try:
            # Obtener informaciÃ³n del video
            video_info = self.get_video_info(url)
            yt = YouTube(url)
            
            # Descargar thumbnail
            thumbnail_data = None
            try:
                response = requests.get(video_info.thumbnail_url, timeout=5)
                if response.status_code == 200:
                    thumbnail_data = response.content
            except:
                pass
            
            # Obtener mejor stream de audio segÃºn tipo
            audio_stream = self._get_best_audio_stream(yt, video_info.is_auto_generated)
            
            # Archivos temporales
            temp_audio = self.temp_dir / f"{uuid.uuid4()}.{self._get_audio_extension(audio_stream)}"
            temp_mp3 = self.temp_dir / f"{uuid.uuid4()}.mp3"
            
            # Descargar audio
            print(f"Descargando audio: {audio_stream.abr} ({audio_stream.mime_type})")
            audio_stream.download(output_path=str(self.temp_dir), filename=temp_audio.name)
            
            # Convertir a MP3 con FFmpeg
            ffmpeg_cmd = [
                "ffmpeg", "-y", "-i", str(temp_audio),
                "-codec:a", "libmp3lame",
                "-q:a", "2",  # Calidad 2 (VBR ~190-250kbps)
                "-vn", str(temp_mp3)
            ]
            
            subprocess.run(ffmpeg_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            
            # AÃ±adir metadatos ID3
            if preserve_metadata and video_info.extracted_metadata:
                self._add_complete_id3_tags(
                    temp_mp3, 
                    video_info,
                    thumbnail_data
                )
            elif preserve_metadata:
                self._add_basic_id3_tags(
                    temp_mp3,
                    video_info.title,
                    video_info.author,
                    "YouTube",
                    thumbnail_data
                )
            
            # Definir nombre de archivo final
            if output_path is None:
                if video_info.extracted_metadata and video_info.extracted_metadata.song_title:
                    base_name = f"{video_info.extracted_metadata.song_title}"
                    if video_info.extracted_metadata.artists:
                        base_name = f"{video_info.extracted_metadata.artists[0]} - {base_name}"
                else:
                    base_name = video_info.title
                
                safe_name = self.sanitize_filename(base_name)
                output_path = Path.cwd() / f"{safe_name}.mp3"
            
            # Mover archivo final
            shutil.move(str(temp_mp3), str(output_path))
            
            # Limpiar temporal
            temp_audio.unlink(missing_ok=True)
            
            return output_path
            
        except Exception as e:
            raise Exception(f"Error descargando MP3: {str(e)}")
    
    # Metodo que aÃ±ade los metadatos ID3 a los videos Auto Generated
    def _add_complete_id3_tags(self, mp3_path: Path, video_info: VideoInfo, 
                               thumbnail_data: Optional[bytes] = None):
        """AÃ±ade metadatos ID3 completos para videos auto-generated"""
        try:
            audio = MP3(str(mp3_path), ID3=ID3)
            if audio.tags is None:
                audio.add_tags()
            
            metadata = video_info.extracted_metadata
            
            # TÃ­tulo de la canciÃ³n
            if metadata.song_title:
                audio.tags.add(TIT2(encoding=3, text=metadata.song_title))
            else:
                audio.tags.add(TIT2(encoding=3, text=video_info.title))
            
            # Artista principal (primer artista)
            if metadata.artists:
                audio.tags.add(TPE1(encoding=3, text=metadata.artists[0]))
                # Album artist (puede ser diferente)
                audio.tags.add(TPE2(encoding=3, text=metadata.artists[0]))
            else:
                audio.tags.add(TPE1(encoding=3, text=video_info.author))
            
            # Ãlbum
            if metadata.album:
                audio.tags.add(TALB(encoding=3, text=metadata.album))
            else:
                audio.tags.add(TALB(encoding=3, text="YouTube"))
            
            # AÃ±o
            if metadata.year:
                audio.tags.add(TYER(encoding=3, text=metadata.year))
            elif video_info.publish_date:
                audio.tags.add(TYER(encoding=3, text=str(video_info.publish_date.year)))
            
            # GÃ©nero (podemos inferir o dejar vacÃ­o)
            audio.tags.add(TCON(encoding=3, text="Soundtrack" if "soundtrack" in metadata.album.lower() else "Music"))
            
            # Comentario con informaciÃ³n adicional
            comment_text = f"Source: YouTube | Channel: {video_info.author}"
            if metadata.label:
                comment_text += f" | Label: {metadata.label}"
            audio.tags.add(COMM(encoding=3, lang='eng', desc='', text=comment_text))
            
            # NÃºmero de pista (podrÃ­amos intentar inferir si es un tracklist)
            # Por ahora dejamos vacÃ­o
            
            # Thumbnail
            if thumbnail_data:
                audio.tags.add(APIC(
                    encoding=3,
                    mime='image/jpeg',
                    type=3,
                    desc='Cover',
                    data=thumbnail_data
                ))
            
            audio.save(v2_version=3)
            
        except Exception as e:
            print(f"Advertencia al aÃ±adir metadatos completos: {e}")
            # Intentar metadatos bÃ¡sicos
            self._add_basic_id3_tags(
                mp3_path,
                video_info.title,
                video_info.author,
                metadata.album if metadata else "YouTube",
                thumbnail_data
            )
    
    # Metodo que aÃ±ade los metadatos basicos - No Auto Generated
    def _add_basic_id3_tags(self, mp3_path: Path, title: str, artist: str, 
                            album: str, thumbnail_data: Optional[bytes] = None):
        """AÃ±ade metadatos ID3 bÃ¡sicos"""
        try:
            audio = MP3(str(mp3_path), ID3=ID3)
            if audio.tags is None:
                audio.add_tags()
            
            audio.tags.add(TIT2(encoding=3, text=title[:100]))
            audio.tags.add(TPE1(encoding=3, text=artist[:100]))
            audio.tags.add(TALB(encoding=3, text=album[:100]))
            
            if thumbnail_data:
                audio.tags.add(APIC(
                    encoding=3,
                    mime='image/jpeg',
                    type=3,
                    desc='Cover',
                    data=thumbnail_data
                ))
            
            audio.save(v2_version=3)
            
        except Exception as e:
            print(f"Advertencia al aÃ±adir metadatos bÃ¡sicos: {e}")
    
    # Metodo para obtener la extencion de video 
    def _get_audio_extension(self, stream) -> str:
        """Obtiene extensiÃ³n apropiada para el stream de audio"""
        mime_type = stream.mime_type.lower()
        
        if 'webm' in mime_type:
            return 'webm'
        elif 'mp4' in mime_type or 'm4a' in mime_type:
            return 'm4a'
        else:
            return 'mp3'
        
    # Metodo especial que se encarga de convertir de 144p a 1080p
    def download_mp4(self, url: str, quality: int = 5, output_path: Optional[Path] = None) -> Path:
        """Descarga y convierte a MP4 con soporte para 240p y 480p"""
        try:
            video_info = self.get_video_info(url)
            yt = YouTube(url)
            
            # Mapear calidad - CON 240p Y 480p
            quality_map = {
                1: "144p",
                2: "240p",      #  NUEVO
                3: "360p",      #  Movido
                4: "480p",      #  NUEVO
                5: "720p",      #  Movido
                6: "1080p",     #  Movido
                7: "max"        #  Movido
            }
            
            # Validar calidad
            if quality not in quality_map:
                quality = 5  # Por defecto 720p (ahora posiciÃ³n 5)
            
            resolution = quality_map.get(quality, "720p")
            
            # Descargar audio
            audio_stream = self._get_best_audio_stream(yt, video_info.is_auto_generated)
            temp_audio = self.temp_dir / f"audio_{uuid.uuid4()}.{self._get_audio_extension(audio_stream)}"
            audio_stream.download(output_path=str(self.temp_dir), filename=temp_audio.name)
            
            # Descargar video
            if quality == 7:  # âœ… max calidad
                video_stream = yt.streams.filter(
                    mime_type="video/mp4",
                    progressive=False
                ).order_by("resolution").desc().first()
            else:
                # Primero buscar exacto
                video_stream = yt.streams.filter(
                    mime_type="video/mp4",
                    res=f"{resolution}",
                    progressive=False
                ).first()
                
                # Si no encuentra, buscar progresivo (audio+video juntos)
                if not video_stream:
                    video_stream = yt.streams.filter(
                        mime_type="video/mp4",
                        res=f"{resolution}",
                        progressive=True
                    ).first()
                
                # Si aÃºn no encuentra, buscar la mejor disponible
                if not video_stream:
                    self._find_best_available_stream(yt, resolution)
            
            if not video_stream:
                raise Exception(f"No se encontrÃ³ video en {resolution}")
            
            temp_video = self.temp_dir / f"video_{uuid.uuid4()}.mp4"
            video_stream.download(output_path=str(self.temp_dir), filename=temp_video.name)
            
            # Si el stream es progresivo (ya tiene audio), no necesitamos combinar
            if video_stream.is_progressive:
                # Solo renombrar
                if output_path is None:
                    if video_info.extracted_metadata and video_info.extracted_metadata.song_title:
                        base_name = f"{video_info.extracted_metadata.song_title}"
                    else:
                        base_name = video_info.title
                    
                    safe_name = self.sanitize_filename(base_name)
                    output_path = Path.cwd() / f"{safe_name}_{resolution}.mp4"
                
                shutil.move(str(temp_video), str(output_path))
                temp_audio.unlink(missing_ok=True)  # No necesitamos audio separado
                
            else:
                # Combinar audio y video
                temp_combined = self.temp_dir / f"combined_{uuid.uuid4()}.mp4"
                
                ffmpeg_cmd = [
                    "ffmpeg", "-y",
                    "-i", str(temp_video),
                    "-i", str(temp_audio),
                    "-c:v", "copy",
                    "-c:a", "aac",
                    "-b:a", "192k",
                    "-shortest",
                    str(temp_combined)
                ]
                
                subprocess.run(ffmpeg_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                
                # Definir nombre de salida
                if output_path is None:
                    if video_info.extracted_metadata and video_info.extracted_metadata.song_title:
                        base_name = f"{video_info.extracted_metadata.song_title}"
                    else:
                        base_name = video_info.title
                    
                    safe_name = self.sanitize_filename(base_name)
                    output_path = Path.cwd() / f"{safe_name}_{resolution}.mp4"
                
                # Mover archivo
                shutil.move(str(temp_combined), str(output_path))
                
                # Limpiar
                temp_audio.unlink(missing_ok=True)
                temp_video.unlink(missing_ok=True)
            
            return output_path
            
        except Exception as e:
            raise Exception(f"Error descargando MP4: {str(e)}")
        
    # Metodo para ontener los streams disponibles de un video
    def get_available_streams(self, url: str) -> list:
        """Obtiene lista de streams disponibles"""
        try:
            yt = YouTube(url)
            streams = []
            
            for stream in yt.streams:
                stream_info = {
                    'itag': stream.itag,
                    'mime_type': stream.mime_type,
                    'resolution': stream.resolution,
                    'abr': stream.abr,
                     # Se ha arreglado en caso de que la api no devuelva el dato
                    'fps': stream.fps if stream.type == "video" and hasattr(stream, "fps") else None,
                    'filesize': stream.filesize_mb if hasattr(stream, 'filesize_mb') else None,
                    'has_audio': stream.includes_audio_track,
                    'is_progressive': stream.is_progressive,
                    'codecs': stream.codecs if hasattr(stream, 'codecs') else None
                }
                
                # Para audio, mostrar bitrate claro
                if stream.type == "audio":  # Se ha arreglado (confusion de metodos)
                    stream_info['type'] = 'audio'
                    if stream.abr:
                        stream_info['quality'] = f"Audio {stream.abr}"
                else:
                    stream_info['type'] = 'video'
                    if stream.resolution:
                        stream_info['quality'] = f"Video {stream.resolution}"
                
                streams.append(stream_info)
            
            return sorted(streams, key=lambda x: (
                0 if x['type'] == 'video' else 1,
                self._parse_resolution(x.get('resolution', '0p')),
                self._parse_bitrate(x.get('abr', '0kbps'))
            ))
            
        except Exception as e:
            raise Exception(f"Error obteniendo streams: {str(e)}")
        
    # Metodo para la resolucion en numero 
    def _parse_resolution(self, res: str) -> int:
        """Convierte resoluciÃ³n a nÃºmero para ordenar"""
        if not res or 'p' not in res:
            return 0
        
        try:
            return int(res.replace('p', ''))
        except:
            return 0
    
    # Metodo que convierte el bitrate a un numero
    def _parse_bitrate(self, abr: str) -> int:
        """Convierte bitrate a nÃºmero para ordenar"""
        if not abr or 'kbps' not in abr:
            return 0
        
        try:
            return int(abr.replace('kbps', ''))
        except:
            return 0
    # metodo que se encarga de obtener la informacion detallada de video
    def get_detailed_info(self, url: str) -> Dict:
        """Obtiene informaciÃ³n detallada del video"""
        try:
            video_info = self.get_video_info(url)
            yt = YouTube(url)
            
            info = {
                'basic': {
                    'title': video_info.title,
                    'channel': video_info.author,
                    'duration': video_info.duration,
                    'duration_formatted': video_info.length_formatted,
                    'views': video_info.views,
                    'publish_date': str(yt.publish_date) if hasattr(yt, 'publish_date') else None,
                    'video_id': video_info.video_id,
                    'is_auto_generated': video_info.is_auto_generated,
                },
                'thumbnail': video_info.thumbnail_url,
                'available_streams': len(yt.streams),
                'description_preview': yt.description[:200] + '...' if len(yt.description) > 200 else yt.description,
            }
            
            # AÃ±adir metadatos extraÃ­dos si existen
            if video_info.extracted_metadata:
                info['music_metadata'] = {
                    'song_title': video_info.extracted_metadata.song_title,
                    'artists': video_info.extracted_metadata.artists,
                    'album': video_info.extracted_metadata.album,
                    'release_date': video_info.extracted_metadata.release_date,
                    'year': video_info.extracted_metadata.year,
                    'label': video_info.extracted_metadata.label,
                    'composers': video_info.extracted_metadata.composers,
                    'is_official': video_info.extracted_metadata.is_official,
                }
            
            return info
            
        except Exception as e:
            raise Exception(f"Error obteniendo info detallada: {str(e)}")
    
    # Metodo para limpiar el nombre de archivo
    def sanitize_filename(self, filename: str) -> str:
        """Limpia el nombre de archivo"""
        # Caracteres invÃ¡lidos en Windows/Linux/Mac
        invalid_chars = '<>:"/\\|?*\''
        for char in invalid_chars:
            filename = filename.replace(char, '')
        
        # Limitar longitud y remover espacios extra
        filename = re.sub(r'\s+', ' ', filename).strip()
        
        return filename[:150]  # Limitar a 150 caracteres
    
    # Metetodo para la limpieza general de la carpeta temp
    def cleanup(self):
        """Limpia archivos temporales"""
        if self.temp_dir.exists():
            try:
                shutil.rmtree(self.temp_dir)
                self.temp_dir.mkdir(exist_ok=True)
            except:
                pass
    
    # Metodo para hacer un checkeo si esta instalado ffmpeg   
    def _check_ffmpeg(self) -> bool:
        """Verifica si FFmpeg estÃ¡ disponible en el sistema"""
        try:
            result = subprocess.run(
                ["ffmpeg", "-version"], 
                capture_output=True, 
                text=True
            )
            return result.returncode == 0
        except (subprocess.SubprocessError, FileNotFoundError):
            return False
        
    def _display_ffmpeg_warning(self):
        """Muestra advertencia amigable sobre FFmpeg"""
        import platform
        
        system = platform.system().lower()
        
        # Instrucciones especÃ­ficas por sistema
        instructions = {
            'windows': (
                "ğŸ“¥ Para instalar FFmpeg en Windows:\n"
                "1. Descarga de: https://ffmpeg.org/download.html\n"
                "2. Busca 'ffmpeg-master-latest-win64-gpl.zip'\n"
                "3. Descomprime y copia la carpeta 'bin' a:\n"
                "   â€¢ C:\\ffmpeg\\  (o cualquier ubicaciÃ³n)\n"
                "4. Agrega a PATH:\n"
                "   â€¢ Presiona Win + X â†’ Sistema â†’ ConfiguraciÃ³n avanzada\n"
                "   â€¢ Variables de entorno â†’ PATH â†’ Editar â†’ Nuevo\n"
                "   â€¢ Agrega: C:\\ffmpeg\\bin\n\n"
                "ğŸ”„ O instala con -> winget install ffmpeg"
            ),
            
            'linux': (
                "ğŸ“¥ Para instalar FFmpeg en Linux:\n"
                "\nâ€¢ Ubuntu/Debian: sudo apt update && sudo apt install ffmpeg\n"
                "â€¢ Fedora/RHEL: sudo dnf install ffmpeg\n"
                "â€¢ Arch/Manjaro: sudo pacman -S ffmpeg\n"
                "â€¢ OpenSUSE: sudo zypper install ffmpeg"
            )
        }
        # Mensaje de advertencia
        warning_msg = f"""
{'='*60}
âš ï¸  ADVERTENCIA: FFmpeg NO ENCONTRADO
{'='*60}
        
â€¢ Funcionalidades limitadas
â€¢ Sin FFmpeg no puedes convertir a MP3/MP4 nativos
        
{instructions.get(system, 'Visita: https://ffmpeg.org/download.html')}
        
{'='*60}
ğŸ’¡ Tip: Reinicia la aplicaciÃ³n despuÃ©s de instalar FFmpeg
{'='*60}
"""        
        print(warning_msg)